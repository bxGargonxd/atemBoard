/* -LICENSE-START-
** Copyright (c) 2021 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include <chrono>
#include <cmath>
#include <cstdlib>
#include <functional>
#include <limits>
#include <map>
#include <stdexcept>

#include "SwitcherStreamingAppDelegate.h"
#include "SwitcherStreamingController.h"

const std::map<BMDSwitcherConnectToFailure, CFStringRef> kConnectToFailureMap =
{
	{ bmdSwitcherConnectToFailureNoResponse,			CFSTR("No response from Switcher") },
	{ bmdSwitcherConnectToFailureIncompatibleFirmware,	CFSTR("Switcher has incompatible firmware") },
};

const std::map<BMDSwitcherStreamRTMPState, CFStringRef> kStreamRTMPStates =
{
	{ bmdSwitcherStreamRTMPStateIdle,			CFSTR("Idle") },
	{ bmdSwitcherStreamRTMPStateConnecting,		CFSTR("Connecting") },
	{ bmdSwitcherStreamRTMPStateStreaming,		CFSTR("Streaming") },
	{ bmdSwitcherStreamRTMPStateStopping,		CFSTR("Stopping") },
};

struct VideoBitrate
{
	uint32_t m_lowBitrate;
	uint32_t m_highBitrate;
};

const std::map<StreamingQuality, VideoBitrate> kStreamQualityVideoBitrates =
{
	{ StreamingQuality::High,	{ 6000000, 9000000 } },
	{ StreamingQuality::Medium,	{ 4500000, 7000000 } },
	{ StreamingQuality::Low,	{ 3000000, 4500000 } },
};

const std::chrono::seconds kDurationUpdatePeriod{1};

SwitcherStreamingController::SwitcherStreamingController(SwitcherStreamingAppDelegate* appDelegate) :
	m_appDelegate(appDelegate),
	m_stopStreaming(false)
{
	m_switcherDiscovery = CreateBMDSwitcherDiscoveryInstance();
	if (!m_switcherDiscovery)
	{
		throw new std::runtime_error("Could not create Switcher Discovery Instance.\nATEM Switcher Software may not be installed.\n");
	}
	
	// Generate switcher monitor and connect callback functions
	m_switcherMonitor = make_com_ptr<SwitcherMonitor>();
	m_switcherMonitor->onSwitcherDisconnected(std::bind(&SwitcherStreamingController::disconnected, this));
	
	// Generate stream monitor and connect callback functions
	m_switcherStreamMonitor = make_com_ptr<SwitcherStreamMonitor>();
	m_switcherStreamMonitor->onServiceNameChanged(std::bind(&SwitcherStreamingController::updateServiceName, this));
	m_switcherStreamMonitor->onStreamURLChanged(std::bind(&SwitcherStreamingController::updateServerUrl, this));
	m_switcherStreamMonitor->onStreamKeyChanged(std::bind(&SwitcherStreamingController::updateStreamKey, this));
	m_switcherStreamMonitor->onVideoBitratesChanged(std::bind(&SwitcherStreamingController::updateStreamQuality, this));
	m_switcherStreamMonitor->onLowLatencyChanged(std::bind(&SwitcherStreamingController::updateLowLatency, this));
	m_switcherStreamMonitor->onStatusUpdated(std::bind(&SwitcherStreamingController::updateStreamingStatus, this, std::placeholders::_1));
	m_switcherStreamMonitor->onTimecodeChanged(std::bind(&SwitcherStreamingController::updateTimecode, this));
	m_switcherStreamMonitor->onCachedUsedChanged(std::bind(&SwitcherStreamingController::updateCacheUsed, this));
	m_switcherStreamMonitor->onEncodingBitrateChanged(std::bind(&SwitcherStreamingController::updateEncodingBitrate, this));
}

SwitcherStreamingController::~SwitcherStreamingController()
{
	// Disconnect handlers from switcher monitor
	m_switcherMonitor->onSwitcherDisconnected(nullptr);

	// Disconnect handlers from stream monitor
	m_switcherStreamMonitor->onServiceNameChanged(nullptr);
	m_switcherStreamMonitor->onStreamURLChanged(nullptr);
	m_switcherStreamMonitor->onStreamKeyChanged(nullptr);
	m_switcherStreamMonitor->onVideoBitratesChanged(nullptr);
	m_switcherStreamMonitor->onLowLatencyChanged(nullptr);
	m_switcherStreamMonitor->onStatusUpdated(nullptr);
	m_switcherStreamMonitor->onTimecodeChanged(nullptr);
	m_switcherStreamMonitor->onCachedUsedChanged(nullptr);
	m_switcherStreamMonitor->onEncodingBitrateChanged(nullptr);
}

bool SwitcherStreamingController::connect(CFStringRef ipAddress)
{
	BMDSwitcherConnectToFailure			failReason;
	BMDSwitcherStreamRTMPState			streamRTMPState;
	BMDSwitcherStreamRTMPError			streamRTMPError;
	CFStringRef							productName;
	HRESULT								result;

	result = m_switcherDiscovery->ConnectTo(ipAddress, m_switcher.releaseAndGetAddressOf(), &failReason);
	if (result != S_OK)
	{
		auto iter = kConnectToFailureMap.find(failReason);
		displayError(iter != kConnectToFailureMap.end() ?
								 iter->second :
								 CFSTR("Connection failed for unknown reason"));

		return false;
	}
	
	result = m_switcher->GetProductName(&productName);
	if (result == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setProductName:(__bridge_transfer NSString*)productName];
		});
	}
	
	result = m_switcher->AddCallback(m_switcherMonitor.get());
	if (result != S_OK)
	{
		displayError(CFSTR("Unable to register IBMDSwitcherCallback"));
		return false;
	}
	
	m_switcherStreamRTMP = com_ptr<IBMDSwitcherStreamRTMP>(IID_IBMDSwitcherStreamRTMP, m_switcher);
	if (!m_switcherStreamRTMP)
	{
		displayError(CFSTR("Switcher does not have streaming interface"));
		return false;
	}

	result = m_switcherStreamRTMP->AddCallback(m_switcherStreamMonitor.get());
	if (result != S_OK)
	{
		displayError(CFSTR("Unable to register IBMDSwitcherStreamRTMPCallback"));
		return false;
	}

	// Send initial settings to the app delegate
	updateServiceName();
	updateServerUrl();
	updateStreamKey();
	updateStreamQuality();
	updateLowLatency();
	
	result = m_switcherStreamRTMP->GetStatus(&streamRTMPState, &streamRTMPError);
	if (result == S_OK)
	{
		if (streamRTMPError == bmdSwitcherStreamRTMPErrorNone)
		{
			updateStreamingStatus(streamRTMPState);
			
			if (streamRTMPState != bmdSwitcherStreamRTMPStateIdle)
				// Switcher is already streaming, monitor timecode, bitrate and cache updates.
				startStreamingThread();
		}
	}
	else
	{
		displayError(CFSTR("Unable to get RTMP stream status"));
		return false;
	}
	
	return true;
}

void SwitcherStreamingController::disconnect()
{
	stopStreamingThread();
	
	if (m_switcherStreamRTMP)
	{
		m_switcherStreamRTMP->RemoveCallback(m_switcherStreamMonitor.get());
		m_switcherStreamRTMP = nullptr;
	}

	if (m_switcher)
	{
		m_switcher->RemoveCallback(m_switcherMonitor.get());
		m_switcher = nullptr;
	}
}

void SwitcherStreamingController::startStreaming()
{
	if (!m_switcherStreamRTMP)
		return;

	if (m_switcherStreamRTMP->StartStreaming() != S_OK)
	{
		displayError(CFSTR("Unable to start RTMP streaming"));
		return;
	}
	
	startStreamingThread();
}

void SwitcherStreamingController::stopStreaming()
{
	if (!m_switcherStreamRTMP)
		return;

	if (m_switcherStreamRTMP->StopStreaming() != S_OK)
		displayError(CFSTR("Unable to stop RTMP streaming"));
}

void SwitcherStreamingController::setServiceName(CFStringRef serviceName)
{
	if (!m_switcherStreamRTMP)
		return;

	if (m_switcherStreamRTMP->SetServiceName(serviceName) != S_OK)
		displayError(CFSTR("Unable to set streaming service name"));
}

void SwitcherStreamingController::setServerUrl(CFStringRef serverUrl)
{
	if (!m_switcherStreamRTMP)
		return;

	if (m_switcherStreamRTMP->SetUrl(serverUrl) != S_OK)
		displayError(CFSTR("Unable to set streaming server URL"));
}

void SwitcherStreamingController::setStreamingKey(CFStringRef streamingKey)
{
	if (!m_switcherStreamRTMP)
		return;

	if (m_switcherStreamRTMP->SetKey(streamingKey) != S_OK)
		displayError(CFSTR("Unable to set streaming key"));
}

void SwitcherStreamingController::setStreamQuality(StreamingQuality quality)
{
	if (!m_switcherStreamRTMP)
		return;

	auto iter = kStreamQualityVideoBitrates.find(quality);
	if (iter != kStreamQualityVideoBitrates.end())
	{
		if (m_switcherStreamRTMP->SetVideoBitrates(iter->second.m_lowBitrate,
												   iter->second.m_highBitrate) != S_OK)
			displayError(CFSTR("Unable to set target video bitrates"));
	}
	else
		displayError(CFSTR("Invalid streaming quality"));
}

void SwitcherStreamingController::setLowLatency(bool lowLatency)
{
	if (!m_switcherStreamRTMP)
		return;

	if (m_switcherStreamRTMP->SetLowLatency(lowLatency) != S_OK)
		displayError(CFSTR("Unable to set low latency streaming"));
}

void SwitcherStreamingController::startStreamingThread()
{
	if (m_streamingThread.joinable())
	{
		displayError(CFSTR("Streaming thread already active"));
		return;
	}
	
	{
		std::lock_guard<decltype(m_mutex)> lock(m_mutex);
		m_stopStreaming = false;
	}
	
	m_streamingThread = std::thread([&] {
		while (true)
		{
			std::unique_lock<decltype(m_mutex)> lock(m_mutex);
			m_conditionVariable.wait_for(lock, kDurationUpdatePeriod, [&] { return m_stopStreaming; });
			
			if (m_stopStreaming)
				break;
			
			if (m_switcherStreamRTMP->RequestDuration() != S_OK)
			{
				displayError(CFSTR("Unable to request duration"));
				break;
			}
		}
	});
}

void SwitcherStreamingController::stopStreamingThread()
{
	{
		std::lock_guard<decltype(m_mutex)> lock(m_mutex);
		m_stopStreaming = true;
	}
	m_conditionVariable.notify_one();
	
	if (m_streamingThread.joinable())
		m_streamingThread.join();
}

void SwitcherStreamingController::disconnected()
{
	disconnect();
	dispatch_async(dispatch_get_main_queue(), ^{
		[m_appDelegate switcherDisconnected];
	});
}


void SwitcherStreamingController::updateServiceName()
{
	CFStringRef serviceName;
	
	if (!m_switcherStreamRTMP)
		return;
	
	if (m_switcherStreamRTMP->GetServiceName(&serviceName) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setServiceName:(__bridge_transfer NSString*)serviceName];
		});
	}
	else
		displayError(CFSTR("Unable to get service name of RTMP stream"));
}

void SwitcherStreamingController::updateServerUrl()
{
	CFStringRef serverUrl;
	
	if (!m_switcherStreamRTMP)
		return;
	
	if (m_switcherStreamRTMP->GetUrl(&serverUrl) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setServerUrl:(__bridge_transfer NSString*)serverUrl];
		});
	}
	else
		displayError(CFSTR("Unable to get server URL of RTMP stream"));
}

void SwitcherStreamingController::updateStreamKey(void)
{
	CFStringRef streamKey;
	
	if (!m_switcherStreamRTMP)
		return;
	
	if (m_switcherStreamRTMP->GetKey(&streamKey) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setStreamKey:(__bridge_transfer NSString*)streamKey];
		});
	}
	else
		displayError(CFSTR("Unable to get key of RTMP stream"));
}

void SwitcherStreamingController::updateStreamQuality(void)
{
	uint32_t lowBitRate;
	uint32_t highBitRate;
	
	if (!m_switcherStreamRTMP)
		return;
	
	if (m_switcherStreamRTMP->GetVideoBitrates(&lowBitRate, &highBitRate) == S_OK)
	{
		long qualityDifference = std::numeric_limits<int>::max();
		StreamingQuality candidateQuality = StreamingQuality::High;

		// Get closest value to defined video bitrates
		for (auto& videoBitrate : kStreamQualityVideoBitrates)
		{
			int diff = std::abs((int)((int)videoBitrate.second.m_lowBitrate - lowBitRate)) +
						std::abs((int)((int)videoBitrate.second.m_highBitrate - highBitRate));
			if (diff < qualityDifference)
			{
				qualityDifference = diff;
				candidateQuality = videoBitrate.first;
			}
		}
		
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setStreamQuality:(NSInteger)candidateQuality];
		});
	}
	else
		displayError(CFSTR("Unable to get video bitrates for RTMP stream"));
}

void SwitcherStreamingController::updateLowLatency(void)
{
	bool lowLatency;
	
	if (!m_switcherStreamRTMP)
		return;
	
	if (m_switcherStreamRTMP->GetLowLatency(&lowLatency) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setLowLatency:(lowLatency ? YES : NO)];
		});
	}
	else
		displayError(CFSTR("Unable to get low latency for RTMP stream"));
}

void SwitcherStreamingController::updateStreamingStatus(BMDSwitcherStreamRTMPState state)
{
	auto iter = kStreamRTMPStates.find(state);
	if (iter != kStreamRTMPStates.end())
	{
		if (state == bmdSwitcherStreamRTMPStateStopping)
			stopStreamingThread();
		
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setStreamingActive:(state != bmdSwitcherStreamRTMPStateIdle)];
			[m_appDelegate setStreamingStatus:(__bridge_transfer NSString*)iter->second];
		});
	}
	else
		displayError(CFSTR("Invalid status for RTMP stream"));
}

void SwitcherStreamingController::updateTimecode(void)
{
	uint8_t hours;
	uint8_t minutes;
	uint8_t seconds;
	uint8_t frames;
	bool dropFrame;
	
	if (!m_switcherStreamRTMP)
		return;
	
	if (m_switcherStreamRTMP->GetTimecode(&hours, &minutes, &seconds, &frames, &dropFrame) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setTimecodeWithHours:(NSInteger)hours
										minutes:(NSInteger)minutes
										seconds:(NSInteger)seconds];
		});
	}
	else
		displayError(CFSTR("Unable to get timecode for RTMP stream"));
}

void SwitcherStreamingController::updateCacheUsed(void)
{
	double cachedUsed;
	
	if (!m_switcherStreamRTMP)
		return;
	
	if (m_switcherStreamRTMP->GetCacheUsed(&cachedUsed) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setCacheUsed:[NSNumber numberWithDouble:cachedUsed]];
		});
	}
	else
		displayError(CFSTR("Unable to get cached used for RTMP stream"));
}

void SwitcherStreamingController::updateEncodingBitrate(void)
{
	uint32_t encodingBitrate;
	
	if (!m_switcherStreamRTMP)
		return;
	
	if (m_switcherStreamRTMP->GetEncodingBitrate(&encodingBitrate) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setEncodingBitrate:(NSInteger)encodingBitrate];
		});
	}
	else
		displayError(CFSTR("Unable to get encoding bitrate for RTMP stream"));
}

void SwitcherStreamingController::displayError(const CFStringRef& error)
{
	NSString* errorString = (__bridge NSString*)error;
	
	dispatch_async(dispatch_get_main_queue(), ^{
		[m_appDelegate showError:@"Switcher Streaming Error"
						  detail:errorString];
	});
}

