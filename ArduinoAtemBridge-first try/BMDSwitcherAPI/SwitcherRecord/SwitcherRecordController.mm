/* -LICENSE-START-
** Copyright (c) 2021 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include <chrono>

#include "SwitcherRecordAppDelegate.h"
#include "SwitcherRecordController.h"

const std::map<BMDSwitcherConnectToFailure, CFStringRef> kConnectToFailureMap =
{
	{ bmdSwitcherConnectToFailureNoResponse,			CFSTR("No response from Switcher") },
	{ bmdSwitcherConnectToFailureIncompatibleFirmware,	CFSTR("Switcher has incompatible firmware") },
};

const std::map<BMDSwitcherRecordAVState, CFStringRef> kRecordAVStateMap =
{
	{ bmdSwitcherRecordAVStateIdle,			CFSTR("Idle") },
	{ bmdSwitcherRecordAVStateRecording,	CFSTR("Recording") },
	{ bmdSwitcherRecordAVStateStopping,		CFSTR("Stopping") },
};

const std::map<BMDSwitcherRecordDiskStatus, CFStringRef> kRecordDiskStatusMap =
{
	{ bmdSwitcherRecordDiskIdle,			CFSTR("Idle") },
	{ bmdSwitcherRecordDiskUnformatted,		CFSTR("Unformatted") },
	{ bmdSwitcherRecordDiskActive,			CFSTR("Active") },
	{ bmdSwitcherRecordDiskRecording,		CFSTR("Recording") },
};

const std::chrono::seconds kDurationUpdatePeriod{1};

enum class WorkingSetIndex : uint32_t
{
	Disk1 = 0,
	Disk2 = 1,
	Count,
};

SwitcherRecordController::SwitcherRecordController(SwitcherRecordAppDelegate* appDelegate) :
	m_appDelegate(appDelegate),
	m_supportsIsoRecording(false)
{
	m_switcherDiscovery = CreateBMDSwitcherDiscoveryInstance();
	if (!m_switcherDiscovery)
	{
			throw new std::runtime_error("Could not create Switcher Discovery Instance.\nATEM Switcher Software may not be installed.\n");
	}
	
	// Generate switcher monitor and connect callback functions
	m_switcherMonitor = make_com_ptr<SwitcherMonitor>();
	m_switcherMonitor->setSwitcherDisconnectedHandler(std::bind(&SwitcherRecordController::disconnected, this));

	// Generate switcher recordAV monitor and connect callback functions
	m_switcherRecordAVMonitor = make_com_ptr<SwitcherRecordAVMonitor>();
	m_switcherRecordAVMonitor->setFilenameChangedHandler(std::bind(&SwitcherRecordController::updateBaseFilename, this));
	m_switcherRecordAVMonitor->setRecordInAllCamerasChangedHandler(std::bind(&SwitcherRecordController::updateRecordInAllCameras, this));
	m_switcherRecordAVMonitor->setRecordAllISOInputsChangedHandler(std::bind(&SwitcherRecordController::updateRecordAllISOInputs, this));
	m_switcherRecordAVMonitor->setRecordingTimeAvailableChangedHandler(std::bind(&SwitcherRecordController::updateTotalRecordingTime, this));
	m_switcherRecordAVMonitor->setTimecodeChangedHandler(std::bind(&SwitcherRecordController::updateTimecode, this));
	m_switcherRecordAVMonitor->setWorkingSetChangedHandler(std::bind(&SwitcherRecordController::updateWorkingSet, this, std::placeholders::_1, std::placeholders::_2));
	m_switcherRecordAVMonitor->setDiskAvailableHandler(std::bind(&SwitcherRecordController::addDiskWithId, this, std::placeholders::_1));
	m_switcherRecordAVMonitor->setDiskRemovedHandler(std::bind(&SwitcherRecordController::removeDiskWithId, this, std::placeholders::_1));
	m_switcherRecordAVMonitor->setStatusUpdatedHandler(std::bind(&SwitcherRecordController::updateRecordState, this, std::placeholders::_1));

	// Generate switcher record disk monitor and connect callback functions
	m_switcherRecordDiskMonitor = make_com_ptr<SwitcherRecordDiskMonitor>();
	m_switcherRecordDiskMonitor->setDiskStatusChangedHandler(std::bind(&SwitcherRecordController::updateDiskStatus, this, std::placeholders::_1));
	m_switcherRecordDiskMonitor->setDiskVolumeNameChangedHandler(std::bind(&SwitcherRecordController::updateDiskVolumeName, this, std::placeholders::_1));
	m_switcherRecordDiskMonitor->setDiskRecordingTimeAvailableChangedHandler(std::bind(&SwitcherRecordController::updateDiskRecordingTimeAvailable, this, std::placeholders::_1));
}

SwitcherRecordController::~SwitcherRecordController()
{
	// Disconnect switcher monitor callback functions
	m_switcherMonitor->setSwitcherDisconnectedHandler(nullptr);

	// Disconnect switcher record AV monitor callback functions
	m_switcherRecordAVMonitor->setFilenameChangedHandler(nullptr);
	m_switcherRecordAVMonitor->setRecordInAllCamerasChangedHandler(nullptr);
	m_switcherRecordAVMonitor->setRecordAllISOInputsChangedHandler(nullptr);
	m_switcherRecordAVMonitor->setRecordingTimeAvailableChangedHandler(nullptr);
	m_switcherRecordAVMonitor->setTimecodeChangedHandler(nullptr);
	m_switcherRecordAVMonitor->setWorkingSetChangedHandler(nullptr);
	m_switcherRecordAVMonitor->setDiskAvailableHandler(nullptr);
	m_switcherRecordAVMonitor->setDiskRemovedHandler(nullptr);
	m_switcherRecordAVMonitor->setStatusUpdatedHandler(nullptr);

	// Disconnect switcher record disk monitor callback functions
	m_switcherRecordDiskMonitor->setDiskStatusChangedHandler(nullptr);
	m_switcherRecordDiskMonitor->setDiskVolumeNameChangedHandler(nullptr);
	m_switcherRecordDiskMonitor->setDiskRecordingTimeAvailableChangedHandler(nullptr);
}

bool SwitcherRecordController::connect(CFStringRef ipAddress)
{
	BMDSwitcherConnectToFailure		failReason;
	BMDSwitcherRecordAVState		recordAVState;
	BMDSwitcherRecordAVError		recordAVError;
	CFStringRef						productName;
	HRESULT							result;

	result = m_switcherDiscovery->ConnectTo(ipAddress, m_switcher.releaseAndGetAddressOf(), &failReason);
	if (result != S_OK)
	{
		auto iter = kConnectToFailureMap.find(failReason);
		displayError(iter != kConnectToFailureMap.end() ?
					 iter->second :
					 CFSTR("Connection failed for unknown reason"));

		return false;
	}
	
	// Update UI with product name
	result = m_switcher->GetProductName(&productName);
	if (result == S_OK)
	{
		 dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setProductName:(__bridge_transfer NSString*)productName];
		 });
	}
	
	result = m_switcher->AddCallback(m_switcherMonitor.get());
	if (result != S_OK)
	{
		displayError(CFSTR("Unable to register IBMDSwitcherCallback"));
		return false;
	}
	
	m_switcherRecordAV = com_ptr<IBMDSwitcherRecordAV>(IID_IBMDSwitcherRecordAV, m_switcher);
	if (!m_switcherRecordAV)
	{
		displayError(CFSTR("Switcher does not have a Record AV interface"));
		return false;
	}

	result = m_switcherRecordAV->AddCallback(m_switcherRecordAVMonitor.get());
	if (result != S_OK)
	{
		displayError(CFSTR("Unable to register IBMDSwitcherStreamRTMPCallback"));
		return false;
	}

	// Display whether ISO recording is supported by this product
	result = m_switcherRecordAV->DoesSupportISORecording(&m_supportsIsoRecording);
	if (result != S_OK)
		m_supportsIsoRecording = false;

	// Send initial value
	if (m_supportsIsoRecording)
		updateRecordAllISOInputs();

	// Send initial values to UI
	updateBaseFilename();
	updateRecordInAllCameras();
	updateTotalRecordingTime();

	// Set initial timecode
	dispatch_async(dispatch_get_main_queue(), ^{
		[m_appDelegate setTimecodeWithHours:(NSInteger)0
									minutes:(NSInteger)0
									seconds:(NSInteger)0];
	});
	
	result = m_switcherRecordAV->GetStatus(&recordAVState, &recordAVError);
	if (result == S_OK)
	{
		if (recordAVError == bmdSwitcherRecordAVErrorNone)
			updateRecordState(recordAVState);
		
		if (recordAVState == bmdSwitcherRecordAVStateRecording)
			// Switcher is already recording, monitor duration
			startRecordingThread();
	}
	else
	{
		displayError(CFSTR("Unable to get record status"));
		return false;
	}
	
	// Iterate through connected disks and add to UI
	iterateDisks();
	
	for (uint32_t i = 0; i < (uint32_t)WorkingSetIndex::Count; ++i)
	{
		BMDSwitcherRecordDiskId diskId;
		result = m_switcherRecordAV->GetWorkingSetDisk(i, &diskId);
		updateWorkingSet(i, result == S_OK ? diskId : kInvalidDiskId);
		updateDiskStatus(diskId);
		updateDiskRecordingTimeAvailable(diskId);
	}
	
	return true;

}

void SwitcherRecordController::disconnect()
{
	stopRecordingThread();
	
	for (auto iter = m_switcherRecordDisks.begin(); iter != m_switcherRecordDisks.end(); )
	{
		iter->second->RemoveCallback(m_switcherRecordDiskMonitor.get());
		iter = m_switcherRecordDisks.erase(iter);
	}
	
	if (m_switcherRecordAV)
	{
		m_switcherRecordAV->RemoveCallback(m_switcherRecordAVMonitor.get());
		m_switcherRecordAV = nullptr;
	}
	
	if (m_switcher)
	{
		m_switcher->RemoveCallback(m_switcherMonitor.get());
		m_switcher = nullptr;
	}
}

void SwitcherRecordController::startRecording()
{
	if (!m_switcherRecordAV)
		return;

	if (m_switcherRecordAV->StartRecording() != S_OK)
	{
		displayError(CFSTR("Unable to start recording"));
		return;
	}

	startRecordingThread();
}

void SwitcherRecordController::stopRecoding()
{
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->StopRecording() != S_OK)
		displayError(CFSTR("Unable to stop recording"));
}

void SwitcherRecordController::switchDisk()
{
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->SwitchDisk() != S_OK)
		displayError(CFSTR("Unable to switch disk"));
}

void SwitcherRecordController::setBaseFilename(CFStringRef baseFilename)
{
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->SetFilename(baseFilename) != S_OK)
		displayError(CFSTR("Unable to set record base filename"));
}

void SwitcherRecordController::setRecordInAllCameras(bool recordInAllCameras)
{
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->SetRecordInAllCameras(recordInAllCameras) != S_OK)
		displayError(CFSTR("Unable to set record in all cameras"));
}

void SwitcherRecordController::setIsoRecording(bool isoRecording)
{
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->SetRecordAllISOInputs(isoRecording) != S_OK)
		displayError(CFSTR("Unable to set record on all ISO inputs"));
}

void SwitcherRecordController::setDisk1WorkingSet(int diskId)
{
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->SetWorkingSetDisk((uint32_t)WorkingSetIndex::Disk1, diskId) != S_OK)
		displayError(CFSTR("Unable to set working set for Disk 1"));
}

void SwitcherRecordController::setDisk2WorkingSet(int diskId)
{
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->SetWorkingSetDisk((uint32_t)WorkingSetIndex::Disk2, diskId) != S_OK)
		displayError(CFSTR("Unable to set working set for Disk 2"));
}

void SwitcherRecordController::startRecordingThread()
{
	if (m_recordThread.joinable())
	{
		displayError(CFSTR("Recording thread already active"));
		return;
	}
	
	{
		std::lock_guard<decltype(m_mutex)> lock(m_mutex);
		m_stopRecording = false;
	}
	
	m_recordThread = std::thread([&] {
		while (true)
		{
			std::unique_lock<decltype(m_mutex)> lock(m_mutex);
			m_conditionVariable.wait_for(lock, kDurationUpdatePeriod, [&] { return m_stopRecording; });
			
			if (m_stopRecording)
				break;
			
			if (m_switcherRecordAV->RequestDuration() != S_OK)
			{
				displayError(CFSTR("Unable to request duration"));
				break;
			}
		}
	});
}

void SwitcherRecordController::stopRecordingThread()
{
	{
		std::lock_guard<decltype(m_mutex)> lock(m_mutex);
		m_stopRecording = true;
	}
	m_conditionVariable.notify_one();
	
	if (m_recordThread.joinable())
		m_recordThread.join();
}

void SwitcherRecordController::displayError(const CFStringRef& error)
{
	NSString* errorString = (__bridge NSString*)error;
	
	dispatch_async(dispatch_get_main_queue(), ^{
		[m_appDelegate showError:@"Switcher Recording Error"
						  detail:errorString];
	});
}

void SwitcherRecordController::disconnected()
{
	{
		std::lock_guard<decltype(m_mutex)> lock(m_mutex);
		m_stopRecording = true;
	}
	m_conditionVariable.notify_one();
	
	dispatch_async(dispatch_get_main_queue(), ^{
		[m_appDelegate switcherDisconnected];
	});
}

void SwitcherRecordController::updateBaseFilename()
{
	CFStringRef baseFilename;
	
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->GetFilename(&baseFilename) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setBaseFilename:(__bridge_transfer NSString*)baseFilename];
		});
	}
	else
	{
		displayError(CFSTR("Unable to get file basename value"));
	}
}

void SwitcherRecordController::updateRecordInAllCameras()
{
	bool recordInAllCameras;
	
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->GetRecordInAllCameras(&recordInAllCameras) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setRecordInAllCameras:(recordInAllCameras ? YES : NO)];
		});
	}
	else
	{
		displayError(CFSTR("Unable to get record in all cameras value"));
	}
}

void SwitcherRecordController::updateRecordAllISOInputs()
{
	bool recordAllISOInputs;
	
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->GetRecordAllISOInputs(&recordAllISOInputs) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setIsoRecording:(recordAllISOInputs ? YES : NO)];
		});
	}
	else
	{
		displayError(CFSTR("Unable to get record all ISO inputs value"));
	}
}

void SwitcherRecordController::updateTotalRecordingTime()
{
	uint32_t totalRecordingTimeAvailable;
	
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->GetTotalRecordingTimeAvailable(&totalRecordingTimeAvailable) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setTotalRecordingTimeAvailable:(NSInteger)totalRecordingTimeAvailable];
		});
	}
	else
	{
		displayError(CFSTR("Unable to get total recording time available"));
	}
}

void SwitcherRecordController::updateTimecode()
{
	uint8_t hours;
	uint8_t minutes;
	uint8_t seconds;
	uint8_t frames;
	bool dropFrame;

	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->GetTimecode(&hours, &minutes, &seconds, &frames, &dropFrame) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setTimecodeWithHours:(NSInteger)hours
										minutes:(NSInteger)minutes
										seconds:(NSInteger)seconds];
		});
	}
	else
	{
		displayError(CFSTR("Unable to get timecode"));
	}
}

void SwitcherRecordController::updateWorkingSet(uint32_t workingSetIndex, BMDSwitcherRecordDiskId diskId)
{
	if (workingSetIndex > (uint32_t)WorkingSetIndex::Disk2)
		return;
	
	dispatch_async(dispatch_get_main_queue(), ^{
		if (workingSetIndex == (uint32_t)WorkingSetIndex::Disk1)
			[m_appDelegate setDisk1Selection:(NSInteger)diskId];
		else
			[m_appDelegate setDisk2Selection:(NSInteger)diskId];
	});
	
	// Update UI with disk status and recording time based for the disk in working set change
	updateDiskStatus(diskId);
	updateDiskRecordingTimeAvailable(diskId);
}

void SwitcherRecordController::addRecordDisk(com_ptr<IBMDSwitcherRecordDisk>& recordDisk)
{
	BMDSwitcherRecordDiskId diskId;
	CFStringRef diskVolumeName;

	if (recordDisk->GetId(&diskId) != S_OK)
	{
		displayError(CFSTR("Unable to get disk ID"));
		return;
	}
	
	if (recordDisk->GetVolumeName(&diskVolumeName) != S_OK)
	{
		displayError(CFSTR("Unable to get disk volume name"));
		return;
	}
	
	if (recordDisk->AddCallback(m_switcherRecordDiskMonitor.get()) != S_OK)
	{
		displayError(CFSTR("Unable register callback with new disk"));
		return;
	}
	
	// Store reference to record disk in map
	m_switcherRecordDisks[diskId] = std::move(recordDisk);
	
	// Update UI with new disk
	dispatch_async(dispatch_get_main_queue(), ^{
		[m_appDelegate addDiskWithDiskId:diskId
							  volumeName:(__bridge_transfer NSString*)diskVolumeName];
	});
}

void SwitcherRecordController::iterateDisks()
{
	com_ptr<IBMDSwitcherRecordDiskIterator>	recordDiskIterator;
	com_ptr<IBMDSwitcherRecordDisk>			recordDisk;

	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->CreateIterator(IID_IBMDSwitcherRecordDiskIterator, (void**)recordDiskIterator.releaseAndGetAddressOf()) != S_OK)
	{
		displayError(CFSTR("Unable to get IBMDSwitcherRecordDiskIterator interface object"));
		return;
	}
	
	while (recordDiskIterator->Next(recordDisk.releaseAndGetAddressOf()) == S_OK)
		addRecordDisk(recordDisk);
}

void SwitcherRecordController::addDiskWithId(BMDSwitcherRecordDiskId diskId)
{
	com_ptr<IBMDSwitcherRecordDiskIterator>	recordDiskIterator;
	com_ptr<IBMDSwitcherRecordDisk>			recordDisk;
	
	if (!m_switcherRecordAV)
		return;
	
	if (m_switcherRecordAV->CreateIterator(IID_IBMDSwitcherRecordDiskIterator, (void**)recordDiskIterator.releaseAndGetAddressOf()) != S_OK)
	{
		displayError(CFSTR("Unable to get IBMDSwitcherRecordDiskIterator interface object"));
		return;
	}

	if (recordDiskIterator->GetById(diskId, recordDisk.releaseAndGetAddressOf()) != S_OK)
	{
		displayError(CFSTR("Unable to get IBMDSwitcherRecordDisk interface object"));
		return;
	}
	
	addRecordDisk(recordDisk);
}

void SwitcherRecordController::removeDiskWithId(BMDSwitcherRecordDiskId diskId)
{
	auto diskIter = m_switcherRecordDisks.find(diskId);
	if (diskIter != m_switcherRecordDisks.end())
		diskIter = m_switcherRecordDisks.erase(diskIter);

	dispatch_async(dispatch_get_main_queue(), ^{
		[m_appDelegate removeDiskWithDiskId:diskId];
	});
}

void SwitcherRecordController::updateRecordState(BMDSwitcherRecordAVState state)
{
	auto iter = kRecordAVStateMap.find(state);
	if (iter != kRecordAVStateMap.end())
	{
		if (state == bmdSwitcherRecordAVStateStopping)
			stopRecordingThread();
		
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setRecordingActive:(state != bmdSwitcherRecordAVStateIdle)];
			[m_appDelegate setRecordingStatus:(__bridge_transfer NSString*)iter->second];
		});
	}
	else
	{
		displayError(CFSTR("Invalid record state"));
	}
}

void SwitcherRecordController::updateDiskStatus(BMDSwitcherRecordDiskId diskId)
{
	BMDSwitcherRecordDiskStatus diskStatus;
	
	auto diskIter = m_switcherRecordDisks.find(diskId);
	if (diskIter == m_switcherRecordDisks.end() || !diskIter->second)
		return;
	
	if (diskIter->second->GetStatus(&diskStatus) == S_OK)
	{
		auto statusIter = kRecordDiskStatusMap.find(diskStatus);
		CFStringRef status = statusIter != kRecordDiskStatusMap.end() ? statusIter->second : CFSTR("Unknown status");
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setDiskStatus:(__bridge_transfer NSString*)status
							   forDiskId:diskId];
		});
	}
	else
	{
		displayError(CFSTR("Unable to get disk status"));
	}
}

void SwitcherRecordController::updateDiskRecordingTimeAvailable(BMDSwitcherRecordDiskId diskId)
{
	uint32_t recordingTimeAvailable;
	
	auto diskIter = m_switcherRecordDisks.find(diskId);
	if (diskIter == m_switcherRecordDisks.end() || !diskIter->second)
		return;
	
	if (diskIter->second->GetRecordingTimeAvailable(&recordingTimeAvailable) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setDiskRecordingTimeAvailable:(NSInteger)recordingTimeAvailable
											   forDiskId:diskId];
		});
	}
	else
	{
		displayError(CFSTR("Unable to get disk recording time available"));
	}
}

void SwitcherRecordController::updateDiskVolumeName(BMDSwitcherRecordDiskId diskId)
{
	CFStringRef diskVolumeName;
	
	auto diskIter = m_switcherRecordDisks.find(diskId);
	if (diskIter == m_switcherRecordDisks.end() || !diskIter->second)
		return;
	
	if (diskIter->second->GetVolumeName(&diskVolumeName) == S_OK)
	{
		dispatch_async(dispatch_get_main_queue(), ^{
			[m_appDelegate setDiskVolumeName:(__bridge_transfer NSString*)diskVolumeName
								   forDiskId:diskId];
		});
	}
	else
	{
		displayError(CFSTR("Unable to get disk volume name"));
	}
}
