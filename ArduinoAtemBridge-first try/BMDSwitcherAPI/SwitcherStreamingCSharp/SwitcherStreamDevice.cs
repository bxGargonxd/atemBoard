/* -LICENSE-START-
** Copyright (c) 2021 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

using BMDSwitcherAPI;

namespace SwitcherStreamingCSharp
{
	#region eventargs
	public class StringEventArgs : EventArgs
	{
		public StringEventArgs(string value) => Value = value;
		public string Value { get; private set; }
	}
	#endregion

	#region exceptions
	class SwitcherConnectException : Exception
	{
		public SwitcherConnectException() : base() { }
		public SwitcherConnectException(string message) : base(message) { }
	}

	class SwitcherStreamInvalidException : Exception
	{
		public SwitcherStreamInvalidException() : base() { }
		public SwitcherStreamInvalidException(string message) : base(message) { }
	}
	#endregion

	public struct VideoBitrate
	{
		public uint Low { get; private set; }
		public uint High { get; private set; }
		public VideoBitrate(uint low, uint high)
		{
			Low = low;
			High = high;
		}
		public override bool Equals(object obj) => (obj is VideoBitrate) && Equals((VideoBitrate)obj);
		public bool Equals(VideoBitrate other) => Low == other.Low && High == other.High;
		public override int GetHashCode()
		{
			var hashCode = -1778393754;
			hashCode = hashCode * -1521134295 + Low.GetHashCode();
			hashCode = hashCode * -1521134295 + High.GetHashCode();
			return hashCode;
		}
		public static bool operator==(VideoBitrate lhs, VideoBitrate rhs) => lhs.Equals(rhs);
		public static bool operator!=(VideoBitrate lhs, VideoBitrate rhs) => !lhs.Equals(rhs);
	}

	class SwitcherStreamDevice
	{
		private readonly IBMDSwitcher switcher;
		private readonly IBMDSwitcherCallback switcherCallback;
		private readonly IBMDSwitcherStreamRTMP switcherStreamRTMP;
		private readonly IBMDSwitcherStreamRTMPCallback switcherStreamRTMPCallback;

		private readonly IReadOnlyDictionary<_BMDSwitcherConnectToFailure, string> ConnectToFailureString = new Dictionary<_BMDSwitcherConnectToFailure, string>()
		{
			{ _BMDSwitcherConnectToFailure.bmdSwitcherConnectToFailureNoResponse,           "No response from Switcher" },
			{ _BMDSwitcherConnectToFailure.bmdSwitcherConnectToFailureIncompatibleFirmware, "Switcher has incompatible firmware" },
		};

		public SwitcherStreamDevice(string ipAddress, SwitcherStreamMonitor streamMonitor, SwitcherMonitor monitor)
		{
			// Create switcher discovery object
			IBMDSwitcherDiscovery discovery = new CBMDSwitcherDiscovery();
			_BMDSwitcherConnectToFailure failureReason = _BMDSwitcherConnectToFailure.bmdSwitcherConnectToFailureNoResponse;

			// Connect to switcher
			try
			{
				discovery.ConnectTo(ipAddress, out switcher, out failureReason);
			}
			catch (Exception)
			{
				throw new SwitcherConnectException(ConnectToFailureString.TryGetValue(failureReason, out string value) ? value : "Connection failed for unknown reason");
			}

			switcherStreamRTMP = switcher as IBMDSwitcherStreamRTMP;

			if (switcherStreamRTMP == null)
			{
				// Switcher does not support stream RTMP interface
				throw new SwitcherStreamInvalidException("Switcher does not have streaming interface");
			}

			switcherCallback = monitor;
			switcher.AddCallback(switcherCallback);

			switcherStreamRTMPCallback = streamMonitor;
			switcherStreamRTMP.AddCallback(switcherStreamRTMPCallback);
		}

		public void Disable()
		{
			switcher.RemoveCallback(switcherCallback);
			switcherStreamRTMP.RemoveCallback(switcherStreamRTMPCallback);
		}

		internal async Task TaskStream(params CancellationToken[] cancellationTokens)
		{
			using (CancellationTokenSource linkedCancelToken = CancellationTokenSource.CreateLinkedTokenSource(cancellationTokens))
			{
				while (true)
				{
					switcherStreamRTMP.RequestDuration();
					await Task.Delay(TimeSpan.FromMilliseconds(1000), linkedCancelToken.Token);
				}
			}
		}

		public void StartStreaming()
		{
			switcherStreamRTMP.StartStreaming();
		}

		public void StopStreaming()
		{
			switcherStreamRTMP.StopStreaming();
		}

		public string ProductName
		{
			get
			{
				switcher.GetProductName(out string productName);
				return productName;
			}
		}

		public bool IsStreaming
		{
			get
			{
				switcherStreamRTMP.IsStreaming(out int streaming);
				return Convert.ToBoolean(streaming);
			}
		}

		public string ServiceName
		{
			get
			{
				switcherStreamRTMP.GetServiceName(out string serviceName);
				return serviceName;
			}
			set => switcherStreamRTMP.SetServiceName(value);
		}

		public string StreamURL
		{
			get
			{
				switcherStreamRTMP.GetUrl(out string url);
				return url;
			}
			set => switcherStreamRTMP.SetUrl(value);
		}

		public string StreamKey
		{
			get
			{
				switcherStreamRTMP.GetKey(out string key);
				return key;
			}
			set => switcherStreamRTMP.SetKey(value);
		}

		public VideoBitrate VideoBitrates
		{
			get
			{
				switcherStreamRTMP.GetVideoBitrates(out uint lowBitRate, out uint highBitRate);
				return new VideoBitrate(lowBitRate, highBitRate);
			}
			set => switcherStreamRTMP.SetVideoBitrates(value.Low, value.High);
		}

		public bool LowLatency
		{
			get
			{
				switcherStreamRTMP.GetLowLatency(out int lowLatency);
				return Convert.ToBoolean(lowLatency);
			}
			set => switcherStreamRTMP.SetLowLatency(Convert.ToInt32(value));
		}

		public _BMDSwitcherStreamRTMPState StreamStatus
		{
			get
			{
				switcherStreamRTMP.GetStatus(out _BMDSwitcherStreamRTMPState state, out _);
				return state;
			}
		}

		public string TimecodeHMSString
		{
			get
			{
				switcherStreamRTMP.GetTimeCode(out byte hours, out byte minutes, out byte seconds, out _, out _);
				return String.Format("{0:D2}:{1:D2}:{2:D2}", hours, minutes, seconds);
			}
		}

		public double CacheUsed
		{
			get
			{
				switcherStreamRTMP.GetCacheUsed(out double cachedUsed);
				return cachedUsed;
			}
		}

		public uint EncodingBitrate
		{
			get
			{
				switcherStreamRTMP.GetEncodingBitrate(out uint encodingBitrate);
				return encodingBitrate;
			}
		}
	}
}
